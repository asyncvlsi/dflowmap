/*
 * This file is part of the ACT library
 *
 * Copyright (c) 2022 Rui Li, Yihang Yang, Rajit Manohar
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 */
import globals;
import std::cells;
import std::channel;
import std::gates;

open std::cells;
open std::channel;
open std::gates;

import "dflow_stdlib.act";

namespace dflowstd {

template <pint V, W>
defproc constant_value(bool! d[W])
{
  (i:W: 
    [((V >> i) & 1) = 0 -> 
      TIELOX1 tielow[i..i]; 
      tielow[i].Y = d[i];
    [] else -> 
      TIEHIX1 tiehigh[i..i]; 
      tiehigh[i].Y = d[i];
    ]
  )
}

export defproc source_dflow <: source()
+{
  bd<W> out; 
}
{
  refine {
  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = out.a;
  reset_nor.Y = out.r;

  constant_value<V, W> consts;
  consts.d = out.d;

  spec {
    timing out.a- -> out.r+
  }
  }
}

export defproc sink_dflow <: sink()
+{
  bd<W> in;
}
{ 
  refine {
  // this signal buffer is needed because it is not allowed to directly connect `in.r' with `in.a'.
  BUFX2 sig_buf;
  sig_buf.A = in.r;
  sig_buf.Y = in.a;
  }
}

/*
 * This is the delay line template. The delay line
 * is a linear chain of 2*N smallest inverters.
 */
export template <pint N>
defproc delay_line(bool? in; bool! out)
{
  INVX1 invs[2*N];
  invs[0].A = in;
  (i:2*N-1 : 
    invs[i].Y = invs[i+1].A;
  )
  invs[2*N-1].Y = out;
}

/* 
 * This is a pulse generator. When the input signal ``in'' changes from 0 to 1, 
 * the output signal ``out'' will transit from 0 to 1, and then from 1 to 0. 
 * The duration of this pulse is controlled by parameter ``PW'' (pulse width), 
 * which determines the number of inverters (2*PW + 1).
 */
export template <pint PW>
defproc pulse(bool? in; bool! out)
{
  INVX1 invs[2*PW+1];
  invs[0].A = in;
  (i:2*PW: 
    invs[i].Y = invs[i+1].A;
  )

  AND2X1 and;
  and.A = in;
  and.B = invs[2*PW].Y;

  out = and.Y;

  spec {
    timing in+: out+ <[1] and.B-
    // this delay margin is a placeholder, its actual value depends on the delay of LATCH
  }
}

/* 
 * This is a data capture unit, which consists of a local variable ``d'' and a 
 * control channel ``go''. When the signal ``go.r'' changes from 0 to 1, this unit 
 * starts sampling the input data ``din''. When the signal ``go.a'' changes from
 * 0 to 1, the data is successfully captured, and can be read from the output ``dout''.
 * 
 * Some parameters, ``W'' is the width of the data; ``CD'' is the capture delay;
 * ``PW'' is the time for latch to successfully store the data.
 */
export template <pint W, CD, PW>
defproc capture(a1of1 go; bool? din[W]; bool! dout[W])
{
  delay_line<CD> capture_delay;
  go.r = capture_delay.in;
  go.a = capture_delay.out;

  pulse<PW> pulse_generator;
  go.r = pulse_generator.in;

  sigbuf<W> fanout_tree;
  pulse_generator.out = fanout_tree.in;

  LATCH x[W];
  (i:W:
    x[i].CLK = fanout_tree.out[i];
    x[i].D = din[i];
    x[i].Q = dout[i];
  )

  spec {
    timing go.r+: dout < go.a+
  }
}

/*
 * This is a template for variables with an initial value.
 */
export template <pint V, W>
defproc var_init(bool? R, CLK, D[W]; bool! Q[W])
{
  sigbuf<W> clk_ftree;
  clk_ftree.in = CLK;
  (i:W: 
    [((V >> i) & 1) = 0 ->
      LATCHLO latch_low[i..i];
      latch_low[i].R = R;
      latch_low[i].CLK = clk_ftree.out[i];
      latch_low[i].D = D[i];
      latch_low[i].Q = Q[i];
    [] else ->
      LATCHHI latch_hi[i..i];
      latch_hi[i].S = R;
      latch_hi[i].CLK = clk_ftree.out[i];
      latch_hi[i].D = D[i];
      latch_hi[i].Q = Q[i];
    ]
  )
}

/*
 * This is the capture unit containing a local variable with an initial value.
 */
export template <pint V, W, CD, PW>
defproc capture_init(a1of1 go; bool? din[W]; bool! dout[W])
{
  delay_line<CD> capture_delay;
  go.r = capture_delay.in;
  go.a = capture_delay.out;

  pulse<PW> pulse_generator;
  go.r = pulse_generator.in;

  var_init<V, W> x;
  x.R = Reset;
  x.CLK = pulse_generator.out;
  x.D = din;
  x.Q = dout;

  spec {
    timing go.r+: dout < go.a+
  }
}

export defproc CELE <: ctree<2, false> () {}
export defproc INVCELE <: ctree<2, true> () {}

/*
 * This is a one-place buffer.
 *
 */
export template<pint CD, PW>
defproc onebuf_dflow <: onebuf() 
+{
  bd<W> in, out;
}
{
  refine {
  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = out.a;

  INVCELE inv_cele;
  inv_cele.in[0] = in.r;
  inv_cele.in[1] = reset_nor.Y;
  INVX1 invc;
  invc.A = inv_cele.out;

  capture<W, CD, PW> data_capture;
  invc.Y = data_capture.go.r;
  data_capture.din = in.d;
  data_capture.dout = out.d;
  data_capture.go.a = in.a;
  data_capture.go.a = out.r;

  spec {
    timing reset_nor.Y+ -> inv_cele.out-
  }

  //spec {
  //  timing invc.Y+: out.d < out.r+
  //}
  }
}

/*
 * This is a one-place buffer with an initial token.
 * This implementation uses a weird reshuffling, and will be replaced soon. 
 *
 */
export template<pint CD, PW>
defproc init_dflow <: init() 
+{
  bd<W> in, out;
}
{
  refine {
  INVCELE inv_cele;
  inv_cele.in[0] = in.r;
  inv_cele.in[1] = out.a;
  INVX1 invc;
  invc.A = inv_cele.out;

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = invc.Y;
  reset_nor.Y = out.r;

  capture_init<V, W, CD, PW> data_capture;
  invc.Y = data_capture.go.r;
  data_capture.go.a = in.a;
  data_capture.din = in.d;
  data_capture.dout = out.d;

  spec {
    timing in.r- -> inv_cele.out+
    timing out.a- -> inv_cele.out+
  }

  //spec {
  //  timing invc.Y+: out.d < in.a+
  //}
  }
}

/*
 * The control unit of M-in-N-out function.
 * In this design, all outputs share the same delay line.
 * Timing constraints need to be specified when this circuit is used to construct the actual function.
 *
 */
export template<pint M, N>
defproc m_in_n_out_func_control(a1of1 in[M]; a1of1 dc[M]; a1of1 out[N]; a1of1 f)
{
  refine {
  ctree<N, false> ack_ctree;
  (i:N: 
    ack_ctree.in[i] = out[i].a;
  )

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = ack_ctree.out;

  INVCELE in_invcs[M];
  INVX1 invcs[M];
  sigbuf<M> nor_ftree;
  ctree<M, false> data_ctree;
  (i:M: 
    in_invcs[i].in[0] = in[i].r; 
    in_invcs[i].in[1] = nor_ftree.out[i]; 
    in_invcs[i].out = invcs[i].A;
    invcs[i].Y = dc[i].r;
    data_ctree.in[i] = dc[i].a;
  )
  nor_ftree.in = reset_nor.Y;
  data_ctree.out = f.r; 

  sigbuf<N> out_ftree;
  out_ftree.in = f.a;
  (i:N: 
    out_ftree.out[i] = out[i].r;
  )

  (i:M:
    spec {
      timing nor_ftree.out[i]+ -> in_invcs[i].out-
    }
  )
  }
}

export template<pint CD, PW>
defproc copy_leaf_dflow <: copy_leaf() 
+{
  bd<W> in, out;
}
{
  refine {
  ctree<N, false> ack_ctree;
  (i:N:
    ack_ctree.in[i] = out[i].a;
  )

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = ack_ctree.out;

  INVCELE in_invc;
  in_invc.in[0] = in.r;
  in_invc.in[1] = reset_nor.Y;
  INVX1 invc;
  invc.A = in_invc.out;

  capture<W, CD, PW> data_capture;
  data_capture.go.r = invc.Y;
  data_capture.din = in.d;
  data_capture.go.a = in.a;
  sigbuf<N> d_ftrees[W]; // fanout tree for each bit
  (b:W:
    data_capture.dout[b] = d_ftrees[b].in;
    (i:N: 
      d_ftrees[b].out[i] = out[i].d[b];
    )
  )

  sigbuf<N> r_ftree;
  data_capture.go.a = r_ftree.in;
  (i:N:
    r_ftree.out[i] = out[i].r;
  )

  spec {
    timing reset_nor.Y+ -> in_invc.out-
  }

  // this is not needed, because the bundled data channel contains timing constraints already
  //(i:N:
  //  spec {
  //    timing in_c.out+: out[i].d < out[i].r+
  //  }
  //)
  }
}

export template<pint CD, PW>
defproc copy_dflow <: copy()
+{
  bd<W> in, out;
}
{
  refine {
  [N <= 8 -> 
    copy_leaf_dflow<CD,PW,W,N> l_dflow(in,out);
  [] else ->
      pint M_dflow = N/8;
      pint F_dflow = N - M_dflow*8;
      copy_leaf_dflow<CD,PW,W,8> t_dflow[M_dflow];
      (i:M_dflow: 
        t_dflow[i].out = out[8*i..8*i+7];
      )
      [ F_dflow > 0 -> 
        copy_leaf_dflow<CD,PW,W,F_dflow> u_dflow;
        copy_dflow<CD,PW,W,M_dflow+1> m_dflow(in);
        (i:M_dflow: 
          m_dflow.out[i] = t_dflow[i].in;
        )
        m_dflow.out[M_dflow] = u_dflow.in;
        u_dflow.out=out[M_dflow*8..N-1];
      [] else -> 
        copy_dflow<CD,PW,W,M_dflow> n_dflow(in);
        (i:M_dflow: 
          n_dflow.out[i] = t_dflow[i].in;
        )
      ]
  ]
  }
}

export template<pint W> 
defproc and_tree(bool? in[W]; bool! out)
{
  [ W > 2 ->
      AND2X1 and;
      and.Y = out;
      and_tree<W/2> l(in[0..W/2-1], and.A);
      and_tree<W-W/2> r(in[W/2..W-1], and.B);
  [] W = 2 ->
      AND2X1 and;
      and.A = in[0];
      and.B = in[1];
      and.Y = out;
  [] else ->
      //in[0] = out;
      // this signal buffer is needed because it is not allowed to directly connect `in[0]' with `out'.
      BUFX2 sig_buf;
      sig_buf.A = in[0];
      sig_buf.Y = out;
  ]
}

export template<pint W; pint N>
defproc address_decoder(bool? in[W]; bool! out[N])
{
  INVX1 invs0[W];
  INVX1 invs1[W];
  (i:W: invs0[i].A = in[i]; invs0[i].Y = invs1[i].A;)

  and_tree<W> atrees[N];
  (i:N:
    (b:W: 
      [((i >> b) & 1) = 0 -> atrees[i].in[b] = invs0[b].Y;
      [] else -> atrees[i].in[b] = invs1[b].Y;
      ]
    )
    atrees[i].out = out[i];
  )
}

template<pint W>
defproc tbufs(bool? A[W], EN; bool! Y[W])
{
  TBUF1 tbs[W];
  sigbuf<W> fanout_tree;
  (i:W: 
        tbs[i].A = A[i]; 
        tbs[i].EN = fanout_tree.out[i];
        tbs[i].Y = Y[i];
  )
  fanout_tree.in = EN;
}

export template<pint ADDR>
defproc unpipe_merge_dflow <: unpipe_merge()
+{
  bd<W1> ctrl;
  bd<W2> in, out;
}
{
  refine {
  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = out.a;

  INVCELE cele;
  cele.in[0] = ctrl.r;
  cele.in[1] = reset_nor.Y;
  INVX1 inv_ctrl;
  inv_ctrl.A = cele.out;

  delay_line<ADDR> addr_dec_delay;
  addr_dec_delay.in = inv_ctrl.Y;

  address_decoder<W1, N> addr_dec;
  addr_dec.in = ctrl.d;

  CELE in_r_c[N];
  CELE in_a_c[N];
  AND2X1 ands[N];
  tbufs<W2> tb[N];
  ortree<N, false> ors;
  sigbuf<N+1> out_a_tree;
  out.a = out_a_tree.in;
  (i:N: 
        ands[i].A = addr_dec_delay.out; 
        ands[i].B = addr_dec.out[i];
        ands[i].Y = in_r_c[i].in[0]; 
        in[i].r = in_r_c[i].in[1];
        in[i].a = in_a_c[i].out;
        in_r_c[i].out = in_a_c[i].in[0];
        in_r_c[i].out = tb[i].EN;
        in_r_c[i].out = ors.in[i];
        tb[i].A = in[i].d;
        tb[i].Y = out.d;
        out_a_tree.out[i] = in_a_c[i].in[1];
  )
  ors.out = out.r;
  ctrl.a = out_a_tree.out[N];

  spec {
    timing reset_nor.Y+ -> cele.out-
  }

  spec {
    timing inv_ctrl.Y+: addr_dec.out < addr_dec_delay.out+
  }
  }
}

export template<pint C_CD, C_PW, ADDR, D_CD, D_PW>
defproc pipe_merge_dflow <: pipe_merge()
+{
  bd<W1> ctrl;
  bd<W2> in, out;
}
{
  refine {
  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = out.a;

  INVCELE cele;
  cele.in[0] = ctrl.r;
  cele.in[1] = reset_nor.Y;
  INVX1 inv_ctrl;
  inv_ctrl.A = cele.out;

  capture<W1, C_CD, C_PW> ctrl_capture;
  ctrl_capture.go.r = inv_ctrl.Y;
  ctrl_capture.din = ctrl.d;
  ctrl.a = ctrl_capture.go.a;

  delay_line<ADDR> addr_dec_delay;
  addr_dec_delay.in = ctrl_capture.go.a;
  address_decoder<W1, N> addr_dec;
  addr_dec.in = ctrl_capture.dout;

  bool data[W2];
  CELE in_r_c[N];
  CELE in_a_c[N];
  AND2X1 ands[N];
  tbufs<W2> tb[N];
  ortree<N, false> ors;
  sigbuf<N> out_a_tree;
  out.a = out_a_tree.in;
  (i:N: 
        ands[i].A = addr_dec_delay.out; 
        ands[i].B = addr_dec.out[i];
        ands[i].Y = in_r_c[i].in[0]; 
        in[i].r = in_r_c[i].in[1];
        in[i].a = in_a_c[i].out;
        in_r_c[i].out = in_a_c[i].in[0];
        in_r_c[i].out = tb[i].EN;
        in_r_c[i].out = ors.in[i];
        tb[i].A = in[i].d;
        tb[i].Y = data;
        out_a_tree.out[i] = in_a_c[i].in[1];
  )

  capture<W2, D_CD, D_PW> data_capture;
  data_capture.go.r = ors.out;
  data_capture.din = data;
  data_capture.go.a = out.r;
  data_capture.dout = out.d;

  spec {
    timing reset_nor.Y+ -> cele.out-
  }

  spec {
    timing inv_ctrl.Y+ : addr_dec.out < addr_dec_delay.out+
  }
  }
}

export template<pint ADDR>
defproc unpipe_split_dflow <: unpipe_split()
+{
  bd<W1> ctrl;
  bd<W2> in, out;
}
{
  refine {
  ortree<N, false> ors;
  (i:N:
    ors.in[i] = out[i].a;
  )

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = ors.out;

  ors.out = in.a;
  ors.out = ctrl.a;

  INVCELE ctrl_c;
  ctrl_c.in[0] = ctrl.r;
  ctrl_c.in[1] = reset_nor.Y;
  INVX1 inv_ctrl;
  inv_ctrl.A = ctrl_c.out;

  delay_line<ADDR> addr_dec_delay;
  inv_ctrl.Y = addr_dec_delay.in;
  address_decoder<W1, N> addr_dec;
  addr_dec.in = ctrl.d;

  INVCELE in_c;
  in_c.in[0] = in.r;
  in_c.in[1] = reset_nor.Y;
  INVX1 inv_inc;
  inv_inc.A = in_c.out;

  CELE all_c;
  all_c.in[0] = inv_inc.Y;
  all_c.in[1] = addr_dec_delay.out;
  sigbuf<N> all_c_tree;
  all_c_tree.in = all_c.out;

  AND2X1 ands[N];
  (i:N: 
    ands[i].A = all_c_tree.out[i];
    ands[i].B = addr_dec.out[i];
    ands[i].Y = out[i].r;
  )
  sigbuf<N> data_tree[W2];
  (b:W2:
    data_tree[b].in = in.d[b];
    (i:N:
      data_tree[b].out[i] = out[i].d[b];
    )
  )

  spec {
    timing reset_nor.Y+ -> ctrl_c.out-
    timing reset_nor.Y+ -> in_c.out-
  }

  spec {
    timing inv_ctrl.Y+: addr_dec.out < all_c.out+
  }
  }
}

export template<pint C_CD, C_PW, ADDR, D_CD, D_PW>
defproc pipe_split_dflow <: pipe_split()
+{
  bd<W1> ctrl;
  bd<W2> in, out;
}
{
  refine {
  ortree<N, false> ors;
  (i:N:
    ors.in[i] = out[i].a;
  )

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = ors.out;

  ors.out = in.a;
  ors.out = ctrl.a;

  INVCELE ctrl_c;
  ctrl_c.in[0] = ctrl.r;
  ctrl_c.in[1] = reset_nor.Y;
  INVX1 inv_ctrl;
  inv_ctrl.A = ctrl_c.out;

  capture<W1, C_CD, C_PW> ctrl_capture;
  ctrl_capture.go.r = inv_ctrl.Y;
  ctrl_capture.din = ctrl.d;
  ctrl_capture.go.a = ctrl.a;

  delay_line<ADDR> addr_dec_delay;
  inv_ctrl.Y = addr_dec_delay.in;
  address_decoder<W1, N> addr_dec;
  addr_dec.in = ctrl_capture.dout;

  INVCELE in_c;
  in_c.in[0] = in.r;
  in_c.in[1] = reset_nor.Y;
  INVX1 inv_inc;
  inv_inc.A = in_c.out;

  bool data[W2];
  capture<W2, D_CD, D_PW> data_capture;
  data_capture.go.r = inv_inc.Y;
  data_capture.din = in.d;
  data_capture.go.a = in.a;
  data_capture.dout = data;

  CELE all_c;
  all_c.in[0] = ctrl_capture.go.a;
  all_c.in[1] = addr_dec_delay.out;
  sigbuf<N> all_c_tree;
  all_c_tree.in = all_c.out;

  AND2X1 ands[N];
  (i:N: 
    ands[i].A = all_c_tree.out[i];
    ands[i].B = addr_dec.out[i];
    ands[i].Y = out[i].r;
  )
  sigbuf<N> data_tree[W2];
  (b:W2:
    data_tree[b].in = data[b];
    (i:N:
      data_tree[b].out[i] = out[i].d[b];
    )
  )

  spec {
    timing reset_nor.Y+ -> ctrl_c.out-
    timing reset_nor.Y+ -> in_c.out-
  }

  spec {
    timing inv_ctrl.Y+: addr_dec.out < all_c.out+
  }
  }
}

export template<pint W; pint N>
defproc address_encoder(bool? in[N]; bool! out[W])
{
  [ W = 1 ->
    [N = 0 -> 
      out[0] = GND;
    [] N = 1 ->
      BUFX2 sig_buf;
      sig_buf.A = in[0];
      sig_buf.Y = out[0];
    [] else ->
      ortree<2, false> or;
      or.in[0] = in[0];
      or.in[1] = in[1];
      or.out = out[0];
    ]
  [] else -> 
    pint H = 1 << (W-1);
    pint R = N - H;
    [ R <= 0 -> 
      address_encoder<W-1, N> ae(in, out[0..W-2]);
      out[W-1] = GND;
    [] R = 1 ->
      BUFX2 sig_buf;
      sig_buf.A = in[N-1];
      sig_buf.Y = out[W-1];
      address_encoder<W-1, H> ae(in[0..H-1], out[0..W-2]);
    [] else -> 
      ortree<R, false> or;
      out[W-1] = or.out;
      (i:H..N-1:
        or.in[i-H] = in[i];
      )
      address_encoder<W-1, H> ae(in[0..H-1], out[0..W-2]);
    ]
  ]  
}

export template<pint ADDR>
defproc unpipe_mixer_dflow <: unpipe_mixer()
+{
  bd<W1> in, out;
  bd<W2> cout;
}
{
  refine {
  CELE c_outs;
  c_outs.in[0] = cout.a;
  c_outs.in[1] = out.a;

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = c_outs.out;
  address_encoder<W2, N> addr_enc;
  sigbuf<N> reset_nor_tree;
  INVCELE c_ins[N];
  INVX1 invs[N];
  ortree<N, false> in_or_tree;
  tbufs<W1> tb[N];
  reset_nor_tree.in = reset_nor.Y;
  (i:N:
    c_ins[i].in[0] = in[i].r;
    c_ins[i].in[1] = reset_nor_tree.out[i];
    c_ins[i].out = invs[i].A;
    invs[i].Y = in_or_tree.in[i];
    invs[i].Y = addr_enc.in[i];
    invs[i].Y = tb[i].EN;
    tb[i].A = in[i].d;
    tb[i].Y = out.d;
  )

  delay_line<ADDR> addr_enc_delay;
  addr_enc_delay.in = in_or_tree.out;
  addr_enc_delay.out = cout.r;
  addr_enc_delay.out = out.r;

  addr_enc.out = cout.d;

  (i:N:
    spec {
      timing reset_nor_tree.out[i]+ -> c_ins[i].out-
    }
  )

  spec {
    timing in_or_tree.out+: addr_enc.out < addr_enc_delay.out+
  }
  }
}

export template<pint ADDR, D_CD, D_PW>
defproc pipe_mixer_dflow <: pipe_mixer()
+{
  bd<W1> in, out;
  bd<W2> cout;
}
{
  refine {
  CELE c_outs;
  c_outs.in[0] = cout.a;
  c_outs.in[1] = out.a;

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = c_outs.out;
  address_encoder<W2, N> addr_enc;
  sigbuf<N> reset_nor_tree;
  INVCELE c_ins[N];
  INVX1 invs[N];
  ortree<N, false> in_or_tree;
  tbufs<W1> tb[N];
  bool data[W1];
  reset_nor_tree.in = reset_nor.Y;
  (i:N:
    c_ins[i].in[0] = in[i].r;
    c_ins[i].in[1] = reset_nor_tree.out[i];
    c_ins[i].out = invs[i].A;
    invs[i].Y = in_or_tree.in[i];
    invs[i].Y = addr_enc.in[i];
    invs[i].Y = tb[i].EN;
    tb[i].A = in[i].d;
    tb[i].Y = data;
  )

  delay_line<ADDR> addr_enc_delay;
  addr_enc_delay.in = in_or_tree.out;

  capture<W1, D_CD, D_PW> data_capture;
  data_capture.go.r = addr_enc_delay.out;
  data_capture.din = data;
  data_capture.go.a = cout.r;
  data_capture.go.a = out.r;
  data_capture.dout = out.d;

  addr_enc.out = cout.d;

  (i:N:
    spec {
      timing reset_nor_tree.out[i]+ -> c_ins[i].out-
    }
  )
  
  spec {
    timing in_or_tree.out+: addr_enc.out < addr_enc_delay.out+
  }
  }
}

}
