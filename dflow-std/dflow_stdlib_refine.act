/*
 * This file is part of the ACT library
 *
 * Copyright (c) 2022 Rui Li, Yihang Yang, Rajit Manohar
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 */
import globals;
import std::cells;
import std::channel;
import std::gates;

open std::gates;
open std::cells;
open std::channel;

import "dflow_stdlib.act";

namespace dflowstd {

template <pint V, W>
defproc constant_value(bool! d[W])
{
  (i:W: 
    [((V >> i) & 1) = 0 -> TIELOX1 tielow[i..i]; tielow[i].Y = d[i];
    [] else -> TIEHIX1 tiehigh[i..i]; tiehigh[i].Y = d[i];
    ]
  )
}

export defproc source_dflow <: source()
+{
  bd<W> out; 
}
{
  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = out.a;
  reset_nor.Y = out.r;
  constant_value<V, W> consts;
  consts.d = out.d;

  spec {
    timing out.a- -> out.r+
  }
}

export defproc sink_dflow <: sink()
+{
  bd<W> in;
}
{ 
  // this signal buffer is needed because it is not allowed to directly connect `in.r' with `in.a'.
  BUFX2 sig_buf;
  sig_buf.A = in.r;
  sig_buf.Y = in.a;
}

export template <pint N>
defproc delay_line(bool? in; bool! out)
{
  INVX1 invs[2*N];
  invs[0].A = in;
  (i:2*N-1 : invs[i].Y = invs[i+1].A;)
  invs[2*N-1].Y = out;
}

/* 
 * This is a pulse generator. When the input signal ``in'' changes from 0 to 1, 
 * the output signal ``out'' will transit from 0 to 1, and then from 1 to 0. 
 * The duration of this pulse is controlled by parameter ``PW'' (pulse width), 
 * which determines the number of inverters (2*PW + 1).
 */
export template <pint PW>
defproc pulse(bool? in; bool! out)
{
  INVX1 invs[2*PW+1];
  invs[0].A = in;
  (i:2*PW: invs[i].Y = invs[i+1].A; )

  AND2X1 and;
  and.A = in;
  and.B = invs[2*PW].Y;

  out = and.Y;

  spec {
    timing in+: out+ <[1] and.B-
    // this delay margin is a placeholder, its actual value depends on the delay of LATCH
  }
}

/* 
 * This is a data capture unit, which consists of a local variable ``d'' and a 
 * control channel ``go''. When the signal ``go.r'' changes from 0 to 1, this unit 
 * starts sampling the input data ``din''. When the signal ``go.a'' changes from
 * 0 to 1, the data is successfully captured, and can be read from the output ``dout''.
 * 
 * Some parameters, ``W'' is the width of the data; ``CD'' is the capture delay;
 * ``PW'' is the time for latch to successfully store the data.
 */
export template <pint W, CD, PW>
defproc capture(a1of1 go; bool? din[W]; bool! dout[W])
{
  delay_line<CD> capture_delay;
  go.r = capture_delay.in;
  go.a = capture_delay.out;

  pulse<PW> pulse_generator;
  go.r = pulse_generator.in;

  sigbuf<W> fanout_tree;
  pulse_generator.out = fanout_tree.in;

  LATCH x[W];
  (i:W: din[i] = x[i].D; x[i].CLK = fanout_tree.out[i]; x[i].Q = dout[i];)

  spec {
    timing go.r+: dout < go.a+
  }
}

template <pint V, W>
defproc variable_value(bool? R, CLK, D[W]; bool! Q[W])
{
  sigbuf<W> clk_ftree;
  clk_ftree.in = CLK;
  (i:W: 
    [((V >> i) & 1) = 0 -> LATCHLO latch_low[i..i]; latch_low[i].R = R; latch_low[i].CLK = clk_ftree.out[i]; latch_low[i].D = D[i]; latch_low[i].Q = Q[i];
    [] else -> LATCHHI latch_hi[i..i]; latch_hi[i].S = R; latch_hi[i].CLK = clk_ftree.out[i]; latch_hi[i].D = D[i]; latch_hi[i].Q = Q[i];
    ]
  )
}

export template <pint V, W, CD, PW>
defproc capture_init(a1of1 go; bool? din[W]; bool! dout[W])
{
  delay_line<CD> capture_delay;
  go.r = capture_delay.in;
  go.a = capture_delay.out;

  pulse<PW> pulse_generator;
  go.r = pulse_generator.in;

  variable_value<V, W> x;
  x.R = Reset;
  x.CLK = pulse_generator.out;
  x.D = din;
  x.Q = dout;

  spec {
    timing go.r+: dout < go.a+
  }
}

export defproc CELE <: ctree<2, false> () {}
export defproc INVCELE <: ctree<2, true> () {}

/*
 * This is a one-place buffer.
 *
 */
export template<pint CD, PW>
defproc onebuf_dflow <: onebuf() 
+{
  bd<W> in, out;
}
{
  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = out.a;

  CELE cele;
  cele.in[0] = in.r;
  cele.in[1] = reset_nor.Y;

  capture<W, CD, PW> data_capture;
  cele.out = data_capture.go.r;
  data_capture.din = in.d;
  data_capture.dout = out.d;
  data_capture.go.a = in.a;
  data_capture.go.a = out.r;

  spec {
    timing cele.out+: out.d < out.r+
  }
}

/*
 * This is a one-place buffer with an initial token.
 * This implementation uses a weird reshuffling, and will be replaced soon. 
 *
 */
export template<pint CD, PW>
defproc init_dflow <: init() 
+{
  bd<W> in, out;
}
{
  CELE cele;
  cele.in[0] = in.r;
  cele.in[1] = out.a;

  bool s;
  s = cele.out;

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = s;
  reset_nor.Y = out.r;

  capture_init<V, W, CD, PW> data_capture;
  cele.out = data_capture.go.r;
  data_capture.go.a = in.a;
  data_capture.din = in.d;
  data_capture.dout = out.d;

  spec {
    timing in.r- -> s-
    timing out.a- -> s-
  }

  spec {
    timing cele.out+: out.d < in.a+
  }
}

/*
 * The control unit of M-in-N-out function.
 * In this design, all outputs share the same delay line.
 * Timing constraints need to be specified when this circuit is used to construct the actual function.
 *
 */
export template<pint M, N>
defproc m_in_n_out_func_control(a1of1 in[M]; a1of1 dc[M]; a1of1 out[N]; a1of1 f)
{
  ctree<N, false> ack_ctree;
  (i:N: ack_ctree.in[i] = out[i].a;)

  OR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = ack_ctree.out;

  CELE celes[M];
  (i:M: in[i].r = celes[i].in[0]; reset_nor.Y = celes[i].in[1]; dc[i].r = celes[i].out;)

  ctree<M, false> data_ctree;
  (i:M: data_ctree.in[i] = dc[i].a;)
  data_ctree.out = f.r;

  sigbuf<N> out_ftree;
  f.a = out_ftree.in;
  (i:N: out_ftree.out[i] = out[i].r;)
}

export template<pint CD, PW>
defproc copy_leaf_dflow <: copy_leaf() 
+{
  bd<W> in, out;
}
{
  ctree<N, false> ack_ctree;
  (i:N: ack_ctree.in[i] = out[i].a;)

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = ack_ctree.out;

  CELE cele;
  cele.in[0] = in.r;
  cele.in[1] = reset_nor.Y;

  capture<W, CD, PW> data_capture;
  cele.out = data_capture.go.r;
  data_capture.din = in.d;
  data_capture.go.a = in.a;
  sigbuf<N> d_ftrees[W]; // fanout tree for each data bit
  (b:W: data_capture.dout[b] = d_ftrees[b].in;
        (i:N: d_ftrees[b].out[i] = out[i].d[b];)
  )

  sigbuf<N> r_ftree;
  in.a = r_ftree.in;
  (i:N: r_ftree.out[i] = out[i].r;)

  spec {
    timing cele.out+: out.d < in.a+
  }
}

export template<pint CD, PW>
defproc copy_dflow <: copy()
+{
  bd<W> in, out;
}
{
  [ N <= 8 -> copy_leaf_dflow<CD,PW,W,N> l_dflow(in,out);
   [] else ->
      pint M_dflow = N/8;
      pint F_dflow = N - M_dflow*8;
      copy_leaf_dflow<CD,PW,W,8> t_dflow[M_dflow];
      (i:M_dflow: t_dflow[i].out = out[8*i..8*i+7];)
      [ F_dflow > 0 -> copy_leaf_dflow<CD,PW,W,F_dflow> u_dflow;
                 copy_dflow<CD,PW,W,M_dflow+1> m_dflow(in);
                 (i:M_dflow: m_dflow.out[i] = t_dflow[i].in;)
                 m_dflow.out[M_dflow] = u_dflow.in;
                 u_dflow.out=out[M_dflow*8..N-1];
      [] else -> copy_dflow<CD,PW,W,M_dflow> n_dflow(in);
                 (i:M_dflow: n_dflow.out[i] = t_dflow[i].in;)
      ]
  ]
}

export template<pint W> 
defproc and_tree(bool? in[W]; bool! out)
{
  [ W > 2 ->
      AND2X1 and;
      and.Y = out;
      and_tree<W/2> l(in[0..W/2-1], and.A);
      and_tree<W-W/2> r(in[W/2..W-1], and.B);
  [] W = 2 ->
      AND2X1 and;
      and.A = in[0];
      and.B = in[1];
      and.Y = out;
  [] else ->
      //in[0] = out;
      // this signal buffer is needed because it is not allowed to directly connect `in[0]' with `out'.
      BUFX2 sig_buf;
      sig_buf.A = in[0];
      sig_buf.Y = out;
  ]
}

export template<pint W; pint N>
defproc address_decoder(bool? in[W]; bool! out[N])
{
  INVX1 invs0[W];
  INVX1 invs1[W];
  (i:W: invs0[i].A = in[i]; invs0[i].Y = invs1[i].A;)

  and_tree<W> atrees[N];
  (i:N:
    (b:W: 
      [((i >> b) & 1) = 0 -> atrees[i].in[b] = invs0[b].Y;
      [] else -> atrees[i].in[b] = invs1[b].Y;
      ]
    )
    atrees[i].out = out[i];
  )
}

template<pint W>
defproc tbufs(bool? A[W], EN; bool! Y[W])
{
  TBUF1 tbs[W];
  sigbuf<W> fanout_tree;
  (i:W: 
        tbs[i].A = A[i]; 
        tbs[i].EN = fanout_tree.out[i];
        tbs[i].Y = Y[i];
  )
  fanout_tree.in = EN;
}

export template<pint ADDR>
defproc unpipe_merge_dflow <: unpipe_merge()
+{
  bd<W1> ctrl;
  bd<W2> in, out;
}
{
  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = out.a;

  CELE cele;
  cele.in[0] = ctrl.r;
  cele.in[1] = reset_nor.Y;

  delay_line<ADDR> add_dec_delay;
  add_dec_delay.in = cele.out;

  address_decoder<W1, N> add_dec;
  add_dec.in = ctrl.d;

  CELE in_r_c[N];
  CELE in_a_c[N];
  AND2X1 ands[N];
  tbufs<W2> tb[N];
  ortree<N, false> ors;
  sigbuf<N+1> out_a_tree;
  out.a = out_a_tree.in;
  (i:N: 
        ands[i].A = add_dec_delay.out; 
        ands[i].B = add_dec.out[i];
        ands[i].Y = in_r_c[i].in[0]; 
        in[i].r = in_r_c[i].in[1];
        in[i].a = in_a_c[i].out;
        in_r_c[i].out = in_a_c[i].in[0];
        in_r_c[i].out = tb[i].EN;
        in_r_c[i].out = ors.in[i];
        tb[i].A = in[i].d;
        tb[i].Y = out.d;
        out_a_tree.out[i] = in_a_c[i].in[1];
  )
  ors.out = out.r;
  ctrl.a = out_a_tree.out[N];

  spec {
    timing cele.out+: add_dec.out < add_dec_delay.out+
  }
}

export template<pint C_CD, C_PW, ADDR, D_CD, D_PW>
defproc pipe_merge_dflow <: pipe_merge()
+{
  bd<W1> ctrl;
  bd<W2> in, out;
}
{
  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = out.a;

  CELE cele;
  cele.in[0] = ctrl.r;
  cele.in[1] = reset_nor.Y;

  capture<W1, C_CD, C_PW> ctrl_capture;
  ctrl_capture.go.r = cele.out;
  ctrl_capture.din = ctrl.d;
  ctrl.a = ctrl_capture.go.a;

  delay_line<ADDR> add_dec_delay;
  add_dec_delay.in = ctrl_capture.go.a;
  address_decoder<W1, N> add_dec;
  add_dec.in = ctrl_capture.dout;

  bool data[W2];
  CELE in_r_c[N];
  CELE in_a_c[N];
  AND2X1 ands[N];
  tbufs<W2> tb[N];
  ortree<N, false> ors;
  sigbuf<N> out_a_tree;
  out.a = out_a_tree.in;
  (i:N: 
        ands[i].A = add_dec_delay.out; 
        ands[i].B = add_dec.out[i];
        ands[i].Y = in_r_c[i].in[0]; 
        in[i].r = in_r_c[i].in[1];
        in[i].a = in_a_c[i].out;
        in_r_c[i].out = in_a_c[i].in[0];
        in_r_c[i].out = tb[i].EN;
        in_r_c[i].out = ors.in[i];
        tb[i].A = in[i].d;
        tb[i].Y = data;
        out_a_tree.out[i] = in_a_c[i].in[1];
  )

  capture<W2, D_CD, D_PW> data_capture;
  data_capture.go.r = ors.out;
  data_capture.din = data;
  data_capture.go.a = out.r;
  data_capture.dout = out.d;

  spec {
    timing cele.out+ : add_dec.out < add_dec_delay.out+
    timing ors.out+ : out.d < out.r+
  }
}

export template<pint ADDR>
defproc unpipe_split_dflow <: unpipe_split()
+{
  bd<W1> ctrl;
  bd<W2> in, out;
}
{
  ortree<N, false> ors;
  (i:N:
        ors.in[i] = out[i].a;
  )

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = ors.out;

  ors.out = in.a;
  ors.out = ctrl.a;

  CELE ctrl_c;
  ctrl_c.in[0] = ctrl.r;
  ctrl_c.in[1] = reset_nor.Y;
  delay_line<ADDR> add_dec_delay;
  ctrl_c.out = add_dec_delay.in;
  address_decoder<W1, N> add_dec;
  add_dec.in = ctrl.d;

  CELE in_c;
  in_c.in[0] = in.r;
  in_c.in[1] = reset_nor.Y;

  CELE all_c;
  all_c.in[0] = in_c.out;
  all_c.in[1] = add_dec_delay.out;
  sigbuf<N> all_c_tree;
  all_c_tree.in = all_c.out;

  AND2X1 ands[N];
  (i:N: 
        ands[i].A = all_c_tree.out[i];
        ands[i].B = add_dec.out[i];
        ands[i].Y = out[i].r;
  )
  sigbuf<N> data_tree[W2];
  (b:W2:
        data_tree[b].in = in.d[b];
        (i:N:
              data_tree[b].out[i] = out[i].d[b];
        )
  )

  spec {
    timing ctrl_c.out+: add_dec.out < all_c.out+
  }
}

export template<pint C_CD, C_PW, ADDR, D_CD, D_PW>
defproc pipe_split_dflow <: pipe_split()
+{
  bd<W1> ctrl;
  bd<W2> in, out;
}
{
  ortree<N, false> ors;
  (i:N:
        ors.in[i] = out[i].a;
  )

  NOR2X1 reset_nor;
  reset_nor.A = Reset;
  reset_nor.B = ors.out;

  ors.out = in.a;
  ors.out = ctrl.a;

  CELE ctrl_c;
  ctrl_c.in[0] = ctrl.r;
  ctrl_c.in[1] = reset_nor.Y;

  capture<W1, C_CD, C_PW> ctrl_capture;
  ctrl_capture.go.r = ctrl_c.out;
  ctrl_capture.din = ctrl.d;
  ctrl_capture.go.a = ctrl.a;

  delay_line<ADDR> add_dec_delay;
  ctrl_c.out = add_dec_delay.in;
  address_decoder<W1, N> add_dec;
  add_dec.in = ctrl_capture.dout;

  CELE in_c;
  in_c.in[0] = in.r;
  in_c.in[1] = reset_nor.Y;

  bool data[W2];
  capture<W2, D_CD, D_PW> data_capture;
  data_capture.go.r = in_c.out;
  data_capture.din = in.d;
  data_capture.go.a = in.a;
  data_capture.dout = data;

  CELE all_c;
  all_c.in[0] = ctrl_capture.go.a;
  all_c.in[1] = add_dec_delay.out;
  sigbuf<N> all_c_tree;
  all_c_tree.in = all_c.out;

  AND2X1 ands[N];
  (i:N: 
        ands[i].A = all_c_tree.out[i];
        ands[i].B = add_dec.out[i];
        ands[i].Y = out[i].r;
  )
  sigbuf<N> data_tree[W2];
  (b:W2:
        data_tree[b].in = data[b];
        (i:N:
              data_tree[b].out[i] = out[i].d[b];
        )
  )

  spec {
    timing ctrl_c.out+ : add_dec.out < all_c.out+
    timing in_c.out+ : out[0..N].d < all_c.out+
  }
}

export template<pint W; pint N>
defproc address_encoder(bool? in[N]; bool! out[W])
{
  [ W = 1 ->
    [N = 0 -> 
      out[0] = GND;
    [] N = 1 ->
      ortree<1, false> or;
      or.in[0] = in[0];
      or.out = out[0];
    [] else ->
      ortree<2, false> or;
      or.in[0] = in[0];
      or.in[1] = in[1];
      or.out = out[0];
    ]
  [] else -> 
    pint H = 1 << (W-1);
    pint R = N - H;
    [ R <= 0 -> 
      address_encoder<W-1, N> ae(in, out[0..W-1]);
      out[W-1] = GND;
    [] else -> 
      ortree<R, false> or;
      out[W-1] = or.out;
      (i:H..N-1:
        or.in[i-H] = in[i];
      )
      address_encoder<W-1, H> ae(in[0..H-1], out[0..W-2]);
    ]
  ]  
}

}
